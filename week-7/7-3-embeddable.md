# 🔸 7-3 Embeddable

## Value Object

* 정의 \
  도메인에서 한 개 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.\

* 왜 필요한가?\
  VO가 필요한 이유는,\
  1\. primitive 타입(int 등)의 기능들을 객체가 전부 사용하지 않는다. 예를 들어, 사각형의 가로, 세로의 길이를  표현할 때 값이 굳이 변할 필요가 없고, 사다리의 가로, 세로도 값이 변하지 않는다. int형은 연산이 가능하다.\
  2\. 값이 여러곳(사각형, 사다리)에서 사용되면, 정보가 여러 곳에 퍼지기 때문에 유효성 검사나 불변체크 등을 해당 값이 있는 모든 객체에서 진행해야한다.\

*   특징(VO 생성시 제약조건)\
    1\. 불변성\
    Setter와 가변 로직이 없는 불변상태여야한다. 이러한 특성 덕분에, VO를 호출하는 쪽에서는 언제 어디서 호출을 하든 값 변경에 대한 걱정을 할 필요가 없다.\
    \
    2\. 동등성\
    생성된 여러 VO가 실제 다른 객체이더라도 (객체 주소값이 다 다르더라도) ‘값’이 같다면 동등한 객체로 판단한다. 각각 고유번호가 다르지만 값은 만원으로 똑같은 지폐를 예시로 생각할 수 있다.

    동등성을 판단하기 위해서 equals & hashCode를 재정의해야한다.\
    \
    3\. 자가 유효성 검사\
    원시 타입을 사용했을 때, 사용하는 모든 곳에서 유효성 검사를 진행해야 한다는 문제점이 있다.

    VO를 사용하면, VO 안에서 생성 시에 유효성 검사를 진행한 후에 생성되어야 한다.

    이러한 특성 덕분에 VO를 사용하는 쪽에서는 유효성 검사가 보장되어 있으므로 안전하게 사용할 수 있다.\

* 사용예시\

* 개인적인 생각(추가적인 질문 또는 내용)\

* 레퍼런스 모음\
  [https://ksh-coding.tistory.com/83](https://ksh-coding.tistory.com/83)

## Aggregate Mapping(집계 매핑)

* 정의 \
  애그리거트는 관련된 객체들의 집합으로, 이들 객체는 함께 논리적으로 묶여 있으며 하나의 단일 단위로 취급됩니다. 이러한 애그리거트들은 서로 다른 객체 간의 상호작용을 통해 도메인 로직을 구현하고, 도메인 모델을 형성합니다.\

* 왜 필요한가?\
  애그리거트 매핑은 이러한 애그리거트들을 영구 저장소(예: 데이터베이스)에 매핑하는 작업을 의미한다. 주로 ORM(Object-Relational Mapping) 라이브러리를 사용하여 객체와 데이터베이스 테이블 간의 매핑을 수행하며, 이를 통해 도메인 객체를 데이터베이스에 저장하고 조회할 수 있다.\

*   관련내용\
    **엔티티 매핑**: 애그리거트 내의 각 객체를 데이터베이스 테이블에 매핑하는 것을 의미한다. 각 엔티티는 데이터베이스 테이블의 레코드와 매핑되며, 엔티티의 속성은 데이터베이스의 열에 매핑된다.\


    **식별자 매핑**: 애그리거트 내의 각 엔티티에 대한 식별자를 데이터베이스 테이블의 기본 키(primary key)에 매핑하는 것을 의미한다. 이를 통해 애그리거트 내의 객체를 고유하게 식별할 수 있다.\


    **관계 매핑**: 애그리거트 간의 관계를 데이터베이스의 관계형 데이터 모델에 매핑하는 것을 의미한다. 관계 매핑을 통해 애그리거트 간의 연관성을 유지하고, 필요에 따라 데이터를 로드하거나 저장할 수 있다.\

* 사용예시\
  @Embedded, @Embeddable을 사용하여 집계 매핑을 지정할 수 있다.\

* 레퍼런스 모음\
  [https://docs.oracle.com/cd/E16439\_01/doc.1013/e13981/cmp30cfg011.htm](https://docs.oracle.com/cd/E16439\_01/doc.1013/e13981/cmp30cfg011.htm)\
  chatGPT

## @Embeddable/@Embedded

* 정의 \
  이 애너테이션들은 비슷하거나 관련된 데이터들을 하나의 객체로 묶을 때 사용된다.
* 왜 필요한가?\
  코드의 응집도와 재사용성을 높여 보다 객체지향적 설계를 하기 위해 필요하다.\

* 사용예시

<figure><img src="../.gitbook/assets/스크린샷 2024-03-14 오후 1.11.12 (2).png" alt="" width="563"><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/스크린샷 2024-03-14 오후 1.11.37 (1).png" alt="" width="563"><figcaption></figcaption></figure>

* 개인적인 생각(추가적인 질문 또는 내용)\
  \- @Embeddable 은 값 타입을 정의하는 곳에 사용하고, @Embedded 은 값 타입을 실행하는 곳에 \
  &#x20; 사용한다. \
  \- 임베디드 타입은 기본 생성자가 필수다. \
  \- 하이버네이트에서 임베디드 타입을 컴포넌트라고 한다.\

* 레퍼런스 모음\
  [https://dandev.tistory.com/entry/JPA-Embedded-Embeddable%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C-%F0%9F%A4%94](https://dandev.tistory.com/entry/JPA-Embedded-Embeddable%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C-%F0%9F%A4%94)
